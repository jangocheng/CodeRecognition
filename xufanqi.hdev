<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.0" halcon_version="10.0" cs="308984251">
<procedure name="main">
<interface/>
<body>
<c></c>
<l>count_seconds(Seconds1)</l>
<l>Fontname:='D:\\xfq\\喷码字符检测\\酱油_label\\4\\'</l>
<c>* Code generated by Image Acquisition 01</c>
<l>list_files ('D:/实习/图片/16.08.12', ['files','follow_links'], ImageFiles)</l>
<l>tuple_regexp_select (ImageFiles, ['\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima)$','ignore_case'], ImageFiles)</l>
<l>for Index :=0 to |ImageFiles| - 1 by 1</l>
<c></c>
<c></c>
<l>    dev_close_window()//关闭窗口的实时更新</l>
<l>    dev_update_window ('off')</l>
<c></c>
<c>*'D:/xfq/喷码字符检测/项目图片/16.08.12/2//C1_3'</c>
<l>    read_image (Image, ImageFiles[Index])</l>
<c>    </c>
<c>    </c>
<l>    parse_filename(ImageFiles[Index], BaseName, Extension, Directory)</l>
<l>    get_image_size (Image, Width1, Height1)</l>
<l>    dev_open_window (0, 0, Width1, Height1, 'black', WindowHandle1)</l>
<l>    dev_display (Image)</l>
<c>   </c>
<c>    </c>
<c>    </c>
<l>    dots_image (Image, DotImage,3, 'dark',2)</l>
<c>    *利用动态阈值进行阈值分割</c>
<l>    mean_image(Image,ImageMean,5,5)</l>
<l>    dyn_threshold(Image,ImageMean,Region,20,'dark')</l>
<c>    *通过闭操作得到整块目标区域</c>
<l>    closing_rectangle1 (Region, RegionClosing, 20, 17)</l>
<l>    closing_circle (RegionClosing, RegionClosing1,5)</l>
<l>    union2(RegionClosing1,Region,Region_union)</l>
<l>    connection (Region_union, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions,ConnectedRegions1,['width','height'], 'and', [100,20], [1000,1000])</l>
<c>    *矫正图片</c>
<c>    *假设有多个区域被选择的情况</c>
<l>    sort_region(ConnectedRegions1, ConnectedRegions1_sort, 'character', 'true', 'row')</l>
<l>    area_center (ConnectedRegions1_sort,Area_connection_para, Row_connection_para, Column_connection_para)</l>
<l>    shape_trans (ConnectedRegions1_sort, Rectangle_para, 'rectangle1') </l>
<l>    sort_region(Rectangle_para, Rectangle_para_sort, 'character', 'true', 'row')</l>
<l>    area_center (Rectangle_para_sort,Area1_rect_para, Row1_rect_para, Column1_rect_para)</l>
<l>    count_obj(ConnectedRegions1_sort,num_para)</l>
<c>    </c>
<l>    for index_j := 0 to num_para-1 by 1</l>
<c>        </c>
<l>        percent_para:=100*Area_connection_para[index_j]/Area1_rect_para[index_j]</l>
<l>        if(percent_para&gt;40)</l>
<l>            select_obj(ConnectedRegions1,ConnectedRegions1_selected,index_j+1)//Index的最小值为1</l>
<l>        endif</l>
<c>    *string 表示要在窗口显示的字符串， coordsystem可以设为‘window’或者‘image'， color 字符显示颜色， row.colum 代表字符显示的行列位置， BOX表示字符是显示在框内还是无框</c>
<l>    endfor</l>
<l>    smallest_rectangle2 (ConnectedRegions1_selected, Row, Column, Phi, Length1, Length2)</l>
<l>    gen_rectangle2(Rectangle,Row,Column,Phi,Length1,Length2)</l>
<c>    </c>
<l>    tuple_deg (Phi, Deg)</l>
<l>    if(Deg&lt;0)</l>
<l>        rotate_image (Image, rotateImage, -Deg, 'constant')</l>
<l>    else </l>
<l>        rotate_image (Image, rotateImage, 360-Deg, 'constant')</l>
<l>    endif</l>
<c>    </c>
<c>  </c>
<c>    </c>
<c>    </c>
<c>    *对旋转之后的新图片重新进行操作</c>
<l>    median_image (rotateImage, rotateImage_m, 'square', 1, 'mirrored')</l>
<l>    dots_image (rotateImage_m, DotImage_r,3, 'dark',2)</l>
<c>    *利用动态阈值进行阈值分割</c>
<l>    mean_image(rotateImage,ImageMean_r,5,5)</l>
<l>    dyn_threshold(rotateImage,ImageMean_r,Region_r,15,'dark')</l>
<c>    *通过闭操作得到整块目标区域</c>
<c>    </c>
<l>    closing_rectangle1 (Region_r, RegionClosing_r, 20, 10)</l>
<l>    closing_circle (RegionClosing_r, RegionClosing1_r,5)</l>
<l>    union2(RegionClosing1_r,Region_r,Region_union_r)</l>
<l>    connection (Region_union_r, ConnectedRegions_r)</l>
<l>    select_shape(ConnectedRegions_r,ConnectedRegions1_r,['width','height'], 'and', [100,20], [1000,1000])</l>
<c>    *矫正图片</c>
<c>    *假设有多个区域被选择的情况</c>
<l>    sort_region(ConnectedRegions1_r, ConnectedRegions1_sort_r, 'character', 'true', 'row')</l>
<l>    area_center (ConnectedRegions1_sort_r,Area_connection_para_r, Row_connection_para_r, Column_connection_para_r)</l>
<l>    shape_trans (ConnectedRegions1_sort_r, Rectangle_para_r, 'rectangle1') </l>
<l>    sort_region(Rectangle_para_r, Rectangle_para_sort_r, 'character', 'true', 'row')</l>
<l>    area_center (Rectangle_para_sort_r,Area1_rect_para_r, Row1_rect_para_r, Column1_rect_para_r)</l>
<l>    count_obj(ConnectedRegions1_sort_r,num_para_r)</l>
<c>    </c>
<l>    for index_j := 0 to num_para_r-1 by 1</l>
<c>        </c>
<l>        percent_para_r:=100*Area_connection_para_r[index_j]/Area1_rect_para_r[index_j]</l>
<l>        if(percent_para_r&gt;40)</l>
<l>            select_obj(ConnectedRegions1_sort_r,ConnectedRegions1_selected_r,index_j+1)//Index的最小值为1</l>
<l>        endif</l>
<c>    *string 表示要在窗口显示的字符串， coordsystem可以设为‘window’或者‘image'， color 字符显示颜色， row.colum 代表字符显示的行列位置， BOX表示字符是显示在框内还是无框</c>
<l>    endfor</l>
<l>    intersection (ConnectedRegions1_selected_r, Region_r, RegionIntersection1_r)</l>
<l>    smallest_rectangle1 (RegionIntersection1_r, Row1_r, Column1_r, Row2_r, Column2_r)</l>
<l>    gen_rectangle1(RegionIntersection1_r,Row1_r,Column1_r,Row2_r, Column2_r)</l>
<l>    intersection(RegionIntersection1_r,Region_r,RegionIntersection2_r)//得到被选中区域内的字符</l>
<c>    *进行水平投影得到字符精准定位，防止噪点带来的干扰</c>
<c>    </c>
<l>*     smallest_rectangle1(Region, Row1, Column1, Row2, Column2) </l>
<l>    width_r:=Column2_r-Column1_r</l>
<l>    height_r:=Row2_r-Row1_r </l>
<c>    *垂直投影</c>
<l>*     for Index := 0 to width_r by 1         </l>
<l>*         gen_rectangle1(Rectangle, Row1, Column1+Index, Row2, Column1+Index) </l>
<l>*         intersection(Region, Rectangle, RegionIntersection) </l>
<l>*         region_features(RegionIntersection, 'area', Value ) </l>
<l>*         VertProjection[Index]:=Value </l>
<l>*     endfor </l>
<c>    *水平投影</c>
<l>    for Index := 0 to height_r by 1     </l>
<l>        gen_rectangle1(Rectangle, Row1_r+Index, Column1_r,  Row1_r+Index, Column2_r) </l>
<l>        intersection(RegionIntersection2_r, Rectangle, RegionIntersection3_r) </l>
<l>        area_center(RegionIntersection3_r,Area,Row,Column)     </l>
<l>        HorProjection[Index]:=Area </l>
<c>        </c>
<l>    endfor </l>
<l>    for Index := 1 to height_r by 1    </l>
<l>        d1[Index]:=HorProjection[Index]-HorProjection[Index-1]</l>
<l>        if(abs(d1[Index])&gt;3 or HorProjection[Index]&gt;5)</l>
<l>            Row1_r:=Row1_r+Index</l>
<l>            break   </l>
<l>        endif        </l>
<l>    endfor </l>
<l>    for Index := height_r to 1 by -1    </l>
<l>        d2[Index]:=HorProjection[Index]-HorProjection[Index-1]</l>
<l>        if(abs(d2[Index])&gt;3 or HorProjection[Index]&gt;5)</l>
<l>            Row2_r:=Row1_r+Index</l>
<l>            break   </l>
<l>        endif        </l>
<l>    endfor    </l>
<c>    *将数组以直方图形式显示    </c>
<l>    *gen_region_histo(HistoImage,HorProjection, 255, 255, 1  ) </l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>    gen_rectangle1 (RectChar1, Row1_r, Column1_r, (Row1_r+Row2_r)/2, Column2_r)</l>
<l>    gen_rectangle1 (RectChar2, (Row1_r+Row2_r)/2, Column1_r, Row2_r, Column2_r)</l>
<c>    </c>
<c></c>
<c>    *首先对第一行进行分割</c>
<l>    intersection (RectChar1, Region_r, RegionIntersection2)</l>
<l>    dilation_circle(RegionIntersection2, RegionIntersection3 ,1 )</l>
<l>    closing_rectangle1 (RegionIntersection3, RegionClosing4, 2, 10)</l>
<l>    closing_circle (RegionClosing4, RegionClosing5,1)</l>
<l>*     gen_rectangle2 (Rectangle1, 10, 10, rad(45), 1, 0)</l>
<l>*     closing (RegionClosing3, Rectangle1, RegionClosing4)</l>
<l>*     gen_rectangle2 (Rectangle2, 10, 10, rad(135), 1, 0)</l>
<l>*     closing (RegionClosing4, Rectangle2, RegionClosing5)</l>
<c>    </c>
<l>    connection (RegionClosing5, ConnectedRegionClosing3)</l>
<l>    shape_trans (ConnectedRegionClosing3, RegionTrans, 'rectangle1')</l>
<l>    union1(RegionTrans,RegionTrans1)</l>
<c>   </c>
<l>    connection (RegionTrans1, ConnectedRegionTrans1)</l>
<c>   </c>
<l>    partition_rectangle(ConnectedRegionTrans1, Partitioned, 13, 38)</l>
<l>    select_shape(Partitioned,ConnectedRegionTrans2,['width','height'], 'and', [2,5], [20,30])</l>
<c>    *对第一行的连通域进行排列</c>
<l>    sort_region(ConnectedRegionTrans2, SortedRegions, 'character', 'true', 'column')</l>
<l>    area_center(SortedRegions, Area, Row, Column)</l>
<c>    </c>
<c>    *************识别阶段</c>
<l>    FontName:='DotPrint.omc'</l>
<l>    read_ocr_class_mlp(FontName, OCRHandle)</l>
<l>    do_ocr_multi_class_mlp (SortedRegions,rotateImage, OCRHandle, RecNum, Confidence) </l>
<c>    </c>
<c>    </c>
<c>    </c>
<l>    set_display_font (WindowHandle1, 20, 'mono', 'true', 'false')</l>
<l>    for i := 0 to |RecNum| - 1 by 1</l>
<l>        disp_message (3600, RecNum[i], 'image', 50,Column[i], 'green', 'false')</l>
<c>    *string 表示要在窗口显示的字符串， coordsystem可以设为‘window’或者‘image'， color 字符显示颜色， row.colum 代表字符显示的行列位置， BOX表示字符是显示在框内还是无框</c>
<l>    endfor</l>
<l>    clear_ocr_class_mlp (OCRHandle)</l>
<c>    </c>
<c>    </c>
<c>    </c>
<c>    *同理，对二行进行识别</c>
<l>    intersection (RectChar2, Region_r, RegionIntersection2_2)</l>
<l>    dilation_circle(RegionIntersection2_2, RegionIntersection3_2 ,1 )</l>
<l>    closing_rectangle1 (RegionIntersection3_2, RegionClosing4_2, 2, 10)</l>
<l>    closing_circle (RegionClosing4_2, RegionClosing5_2,2)</l>
<c>    </c>
<l>*     gen_rectangle2 (Rectangle1_2, 10, 10, rad(45), 1, 0)</l>
<l>*     closing (RegionClosing3_2, Rectangle1, RegionClosing4_2)</l>
<l>*     gen_rectangle2 (Rectangle2_2, 10, 10, rad(135), 1, 0)</l>
<l>*     closing (RegionClosing4_2, Rectangle2_2, RegionClosing5_2)</l>
<c>   </c>
<l>    connection (RegionClosing5_2, ConnectedRegionClosing3_2)</l>
<l>    shape_trans (ConnectedRegionClosing3_2, RegionTrans_2, 'rectangle1')</l>
<l>    union1(RegionTrans_2,RegionTrans1_2)</l>
<c>    </c>
<l>    connection (RegionTrans1_2, ConnectedRegionTrans2_2)</l>
<l>    partition_rectangle(ConnectedRegionTrans2_2, Partitioned_2, 15, 25)</l>
<l>    select_shape(Partitioned_2,RegionTrans2_2,['width','height'], 'and', [2,5], [20,30])</l>
<c>    *对第一行的连通域进行排列</c>
<l>    sort_region(RegionTrans2_2, SortedRegions_2, 'character', 'true', 'column')</l>
<l>    area_center(SortedRegions_2, Area, Row, Column)</l>
<c>    </c>
<c>    *************识别阶段</c>
<l>    FontName:='DotPrint.omc'</l>
<l>    read_ocr_class_mlp(FontName, OCRHandle)</l>
<l>    do_ocr_multi_class_mlp (SortedRegions_2,rotateImage, OCRHandle, RecNum_2, Confidence) </l>
<l>    set_display_font (WindowHandle1, 20, 'mono', 'true', 'false')</l>
<l>    for i := 0 to |RecNum_2| - 1 by 1</l>
<l>        disp_message (3600, RecNum_2[i], 'image', 100,Column[i], 'green', 'false')</l>
<c>    *string 表示要在窗口显示的字符串， coordsystem可以设为‘window’或者‘image'， color 字符显示颜色， row.colum 代表字符显示的行列位置， BOX表示字符是显示在框内还是无框</c>
<l>    endfor</l>
<l>    dump_window_image (Image_write, WindowHandle1)</l>
<l>    write_image (Image_write, 'bmp', 0,Fontname+BaseName+'_1')</l>
<l>    clear_ocr_class_mlp (OCRHandle)</l>
<c>    </c>
<l>    count_seconds(Seconds2)</l>
<l>    Time:=(1000*(Seconds2-Seconds1))</l>
<l>endfor</l>
<c></c>
<c>* create_funct_1d_pairs</c>
<c>* local_min_max_funct_1d</c>
<c>    </c>
<c>    </c>
<c>*得到某一点的灰度值</c>
<l>*get_grayval(Image ,204,174,Grayval )</l>
<l>*threshold (DotImage, Regions, 200, 255)</l>
<c></c>
<l>* dev_display (Regions)</l>
<l>* closing_circle (Regions, RegionClosing5,34)</l>
<l>* connection (RegionClosing5, ConnectedRegions6)</l>
<c></c>
<l>* select_shape (ConnectedRegions6, SelectedRegions7, ['width','height'], 'and', [50,20], [300,80])</l>
<l>* select_shape_std (SelectedRegions7, SelectedRegions5, 'max_area', 70)</l>
<c></c>
<l>* smallest_rectangle2 (SelectedRegions5, Row, Column, Phi, Length1, Length2)</l>
<l>* gen_rectangle2(Rectangle,Row,Column,Phi,Length1,Length2)</l>
<l>* set_draw(WindowHandle,'margin')</l>
<l>* disp_region(Rectangle,WindowHandle)</l>
<c>*将元组从弧度转换为度数。</c>
<l>* tuple_deg (Phi, Deg)</l>
<l>* rotate_image (Image, rotateImage, -Deg, 'constant')</l>
<c>*以上是旋转图片</c>
<c>*以下是对旋转之后得到的矫正图片进行处理</c>
<l>* dots_image (rotateImage, DotImage1, 3, 'dark', 2)</l>
<l>* threshold (DotImage1, Region, 100, 255)</l>
<c></c>
<l>* connection (Region, ConnectedRegions)</l>
<l>* select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 2, 576)</l>
<c>*返回所有输入区域的并集。</c>
<l>* union1 (SelectedRegions, RegionUnion)</l>
<l>* closing_rectangle1 (RegionUnion, RegionClosing, 70, 7)</l>
<c></c>
<l>* closing_circle (RegionUnion, RegionClosing7, 10)</l>
<c>*计算两个区域的交集。</c>
<l>* intersection (RegionClosing7, RegionClosing, RegionIntersection6)</l>
<c></c>
<l>* connection (RegionIntersection6, ConnectedRegions1)</l>
<l>* select_shape (ConnectedRegions1, SelectedRegions1, ['height','area'], 'and', [20,3000], [90,99999])</l>
<c></c>
<l>* union1 (SelectedRegions1, RegionUnion1)</l>
<c>*通过区域的交集得到目标文字区域</c>
<l>* intersection (RegionUnion1, RegionUnion, RegionIntersection)</l>
<c>*以上是获取整个字符区域</c>
<l>* smallest_rectangle1 (RegionUnion1, RowChar1, ColumnChar1, RowChar2, ColumnChar2)</l>
<l>* gen_rectangle1 (RectChar1, RowChar1, ColumnChar1, (RowChar1+RowChar2)/2, ColumnChar2)</l>
<l>* gen_rectangle1 (RectChar2, (RowChar1+RowChar2)/2, ColumnChar1, RowChar2, ColumnChar2)</l>
<c>*每一行生成一个矩形</c>
<l>* intersection (RegionIntersection, RectChar1, RegionIntersection2)</l>
<l>* closing_rectangle1 (RegionIntersection2, RegionClosing3, 1, 5)</l>
<l>* closing_circle (RegionClosing3, RegionClosing1, 2)</l>
<c></c>
<l>* connection (RegionClosing1, ConnectedRegions4)</l>
<l>* shape_trans (ConnectedRegions4, RegionTrans, 'rectangle1')</l>
<l>* union1(RegionTrans,Region_union)</l>
<l>* connection (Region_union, Connected_union)</l>
<c>*partition_rectangle的目的是将区域划分为相同矩形</c>
<l>* partition_rectangle (Connected_union, Partitioned, 15, 38)</l>
<l>* select_shape (Partitioned, SelectedRegions3, 'height', 'and', 1, 44)</l>
<l>* intersection (Region_union, RegionIntersection2, RegionIntersection3)</l>
<l>* connection (Partitioned, Connected) </l>
<c>*以上是分割第一行字符</c>
<l>* sort_region (RegionIntersection3, SortedRegions, 'character', 'true', 'row')</l>
<l>* count_obj (SortedRegions, Number1)</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
